<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Minecraft (Replit-ready)</title>
<style>
  html,body{height:100%;margin:0;overflow:hidden;font-family:sans-serif}
  #ui { position:fixed; left:12px; top:12px; z-index:30; color:#fff; }
  #inv { position:fixed; right:12px; top:12px; z-index:30; background:rgba(0,0,0,0.4); padding:8px; border-radius:8px; color:#fff; }
  #menu{ position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); z-index:50; display:none; background:#111; color:#fff; padding:16px; border-radius:8px; width:300px; text-align:center;}
  canvas{display:block}
  button{padding:6px 10px;margin:4px}
</style>
</head>
<body>
<div id="ui">Mode: <span id="mode">Third-person</span> • Press <b>V</b> to toggle view • <b>Esc</b> for menu</div>
<div id="inv">
  Inventory<br/>
  <div>Selected: <span id="selName">dirt</span></div>
  <div style="margin-top:6px;">
    <button data-type="dirt">dirt</button>
    <button data-type="grass">grass</button>
    <button data-type="stone">stone</button>
  </div>
  <small style="display:block;margin-top:6px">Left click place • Right click break</small>
</div>
<div id="menu"><h3>Menu</h3><button id="resumeBtn">Resume</button><div style="margin-top:10px"><small>Server: wss:// (same host)</small></div></div>

<!-- Three.js UMD build -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<script>
/* ---------- CONFIG ---------- */
const BLOCK_TYPES = {
  dirt: { color: 0x8B4513 },
  grass: { color: 0x228B22 },
  stone: { color: 0xC2B280 }
};
/* ---------------------------- */

let scene, camera, renderer;
let player, playerVel = new THREE.Vector3(), onGround = false;
let world = {}, pickables = [];
let selected = 'dirt';
let firstPerson = false;

// WebSocket: connect to same host (works on Replit)
const SERVER_ADDR = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host;
let ws = null;

function setupWS(){
  try {
    ws = new WebSocket(SERVER_ADDR);
  } catch(e){
    console.warn('WS connect error', e);
    return;
  }
  ws.onopen = () => console.log('WS connected');
  ws.onmessage = (m) => {
    try {
      const d = JSON.parse(m.data);
      // handle remote events (place/remove/move)
      if(d.t === 'place') addBlock(d.x,d.y,d.z,d.type,false);
      if(d.t === 'remove') removeBlock(d.x,d.y,d.z,false);
      // other message types can be added
    } catch(e) { console.error(e); }
  };
  ws.onclose = () => console.log('WS closed');
}

/* ---------- SCENE ---------- */
function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

  // basic lights
  const hemi = new THREE.HemisphereLight(0xffffee, 0x444444, 0.9);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.7);
  dir.position.set(10,20,10);
  dir.castShadow = true;
  scene.add(dir);

  // ground
  const size = 12;
  for(let x=-size; x<=size; x++){
    for(let z=-size; z<=size; z++){
      addBlock(x,0,z, Math.random()>0.9 ? 'grass' : 'dirt', false);
    }
  }

  // player group (simple)
  player = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.8,1.0,0.4), new THREE.MeshLambertMaterial({color:0x00aaff}));
  body.position.set(0,1.25,0);
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.7,0.7,0.7), new THREE.MeshLambertMaterial({color:0xffd9b3}));
  head.position.set(0,1.9,0);
  player.add(body, head);
  player.position.set(0,3,5);
  scene.add(player);

  // events
  window.addEventListener('resize', onResize);
  window.addEventListener('keydown', onKeyDown);
  window.addEventListener('keyup', onKeyUp);
  window.addEventListener('mousedown', onMouseDown);
  window.addEventListener('contextmenu', e => e.preventDefault());

  document.querySelectorAll('#inv button').forEach(b=> b.onclick = ()=> { selected = b.dataset.type; document.getElementById('selName').innerText = selected; });
  document.getElementById('resumeBtn').onclick = ()=> toggleMenu(false);

  setupWS();
  animate();
}

function onResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

/* ---------- BLOCKS ---------- */
const blockGeo = new THREE.BoxGeometry(1,1,1);
const mats = {
  dirt: new THREE.MeshLambertMaterial({color:BLOCK_TYPES.dirt.color}),
  grass: new THREE.MeshLambertMaterial({color:BLOCK_TYPES.grass.color}),
  stone: new THREE.MeshLambertMaterial({color:BLOCK_TYPES.stone.color})
};

function k(x,y,z){return `${x},${y},${z}`;}
function addBlock(x,y,z,type='dirt',sync=true){
  const id = k(x,y,z);
  if(world[id]) return;
  const m = new THREE.Mesh(blockGeo, mats[type]);
  m.position.set(x,y,z);
  m.userData = { type };
  scene.add(m);
  world[id] = m;
  pickables.push(m);
  if(sync && ws && ws.readyState===1) ws.send(JSON.stringify({t:'place',x,y,z,type}));
}
function removeBlock(x,y,z,sync=true){
  const id = k(x,y,z);
  const m = world[id];
  if(!m) return;
  scene.remove(m);
  const i = pickables.indexOf(m); if(i!==-1) pickables.splice(i,1);
  delete world[id];
  if(sync && ws && ws.readyState===1) ws.send(JSON.stringify({t:'remove',x,y,z}));
}

/* ---------- INPUT + MOVEMENT ---------- */
const keys = {};
function onKeyDown(e){ keys[e.key.toLowerCase()] = true; if(e.key==='Escape') toggleMenu(true); if(e.key.toLowerCase()==='v') { firstPerson=!firstPerson; document.getElementById('mode').innerText = firstPerson?'First-person':'Third-person'; } }
function onKeyUp(e){ keys[e.key.toLowerCase()] = false; }

let mouseDownPos = null;
function onMouseDown(e){
  // treat as click if small movement on mouseup
  if(e.button === 0 || e.button === 2){
    // compute ray
    const rect = renderer.domElement.getBoundingClientRect();
    const mx = ( (e.clientX - rect.left) / rect.width ) * 2 - 1;
    const my = - ( (e.clientY - rect.top) / rect.height ) * 2 + 1;
    const ray = new THREE.Raycaster();
    ray.setFromCamera(new THREE.Vector2(mx,my), camera);
    const ints = ray.intersectObjects(pickables, false);
    if(!ints.length) return;
    const hit = ints[0];
    const pos = hit.object.position.clone();
    if(e.button === 2){ // right click break
      removeBlock(pos.x,pos.y,pos.z,true);
    } else {
      // left click place adjacent
      const n = hit.face.normal.clone();
      const np = pos.clone().add(n);
      addBlock(Math.round(np.x), Math.round(np.y), Math.round(np.z), selected, true);
    }
  }
}

/* ---------- PHYSICS (simple) ---------- */
let last = performance.now();
function simulate(dt){
  const speed = 6;
  // camera forward for movement
  const camDir = new THREE.Vector3();
  camera.getWorldDirection(camDir); camDir.y = 0; camDir.normalize();
  const camRight = new THREE.Vector3().crossVectors(camDir, camera.up).normalize();

  const move = new THREE.Vector3();
  if(keys['w']) move.add(camDir);
  if(keys['s']) move.sub(camDir);
  if(keys['a']) move.sub(camRight);
  if(keys['d']) move.add(camRight);
  move.normalize();

  // smooth XZ velocity
  const target = move.multiplyScalar(speed);
  playerVel.x = THREE.MathUtils.lerp(playerVel.x, target.x, 0.12);
  playerVel.z = THREE.MathUtils.lerp(playerVel.z, target.z, 0.12);

  // gravity and jump
  const GRAV = -25;
  playerVel.y += GRAV * dt;
  if(keys[' '] && onGround){
    playerVel.y = 8; onGround = false;
  }

  // integrate
  const newPos = player.position.clone().add(playerVel.clone().multiplyScalar(dt));

  // very simple ground collision: if below y=0.9 snap to ground (we use blocks as terrain so this is simplified)
  if(newPos.y <= 1.0){
    newPos.y = 1.0; playerVel.y = 0; onGround = true;
  }

  player.position.copy(newPos);

  // rotate player toward movement
  const flatVel = new THREE.Vector3(playerVel.x,0,playerVel.z);
  if(flatVel.lengthSq()>0.001){
    const look = flatVel.clone().normalize();
    const ang = Math.atan2(look.x, look.z);
    player.rotation.y = ang;
  }

  // camera follow
  updateCamera();
}

function updateCamera(){
  if(firstPerson){
    const head = new THREE.Vector3();
    player.children[1].getWorldPosition(head);
    camera.position.copy(head).add(new THREE.Vector3(0,0.12,0));
    camera.lookAt(head.clone().add(player.getWorldDirection(new THREE.Vector3()).multiplyScalar(10)));
  } else {
    const offset = new THREE.Vector3(0,2.4,6);
    const worldPos = player.position.clone();
    const camPos = worldPos.clone().add(offset);
    camera.position.lerp(camPos, 0.18);
    camera.lookAt(worldPos.clone().add(new THREE.Vector3(0,1.2,0)));
  }
}

/* ---------- RENDER LOOP ---------- */
function animate(){
  const now = performance.now();
  const dt = Math.min(0.05, (now - last)/1000);
  last = now;
  simulate(dt);
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

/* ---------- UI ---------- */
function toggleMenu(show){
  document.getElementById('menu').style.display = show ? 'block' : 'none';
}

/* ---------- start ---------- */
init();
</script>
</body>
</html>
