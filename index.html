<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Mini-Minecraft — SP / MP UI + Host</title>
<style>
  html,body{height:100%;margin:0;overflow:hidden;background:#87ceeb;font-family:Segoe UI,Arial}
  canvas{display:block}
  #topbar{position:fixed;left:10px;top:10px;z-index:80}
  #controls{position:fixed;left:10px;top:60px;z-index:80;background:rgba(0,0,0,0.45);padding:10px;border-radius:8px;color:#fff}
  #controls button{display:block;margin:6px 0;padding:8px;width:220px;border-radius:6px;border:none;background:#2c7;cursor:pointer}
  #controls button.mp{background:#29a; width:220px}
  #serverPanel{margin-top:8px;display:none}
  #serverPanel input{width:210px;padding:6px;border-radius:6px;border:1px solid #333;margin-bottom:6px}
  #status{margin-top:6px;font-size:12px;color:#ffd}
  #menuNote{position:fixed;right:10px;top:10px;color:#fff;background:rgba(0,0,0,0.25);padding:8px;border-radius:6px;z-index:80}
  #hotbar{position:fixed;left:50%;transform:translateX(-50%);bottom:14px;display:flex;gap:8px;z-index:80}
  .slot{width:64px;height:64px;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;color:#fff;border-radius:6px;cursor:pointer}
  .sel{outline:3px solid #ffd700}
  #menu {position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#111;color:#fff;padding:12px;border-radius:8px;display:none;z-index:90}
  #dbg{position:fixed;right:10px;bottom:10px;width:380px;height:220px;background:rgba(0,0,0,0.85);color:#0f0;padding:8px;border-radius:6px;font-family:monospace;font-size:12px;overflow:auto;z-index:100}
  #dbg .err{color:#ff8080} #dbg .warn{color:#ffd080}
</style>
</head>
<body>
  <div id="topbar"><strong>Mini-Minecraft</strong></div>

  <div id="controls">
    <button id="btnSingle">Play: Single Player</button>
    <button class="mp" id="btnMP">Play: Multiplayer</button>

    <div id="serverPanel">
      <div><input id="serverAddr" placeholder="wss://your-server.example (leave blank = same host)"></div>
      <div><button id="btnConnect">Connect</button> <button id="btnDisconnect">Disconnect</button></div>
      <div id="status">Status: <span id="statText">not connected</span></div>
      <div style="margin-top:8px"><button id="btnHost">Host on my PC — Show instructions</button></div>
    </div>
  </div>

  <div id="menuNote">WASD move • Shift sprint • Space jump • Left click place • Right click break • 1/2/3 select</div>

  <div id="hotbar">
    <div class="slot sel" data-type="dirt">Dirt<br/><small>1</small></div>
    <div class="slot" data-type="grass">Grass<br/><small>2</small></div>
    <div class="slot" data-type="stone">Stone<br/><small>3</small></div>
  </div>

  <div id="menu">
    <h3>Host instructions</h3>
    <p>To host a multiplayer world from your PC you must run the Node server and keep your machine online:</p>
    <pre style="text-align:left;background:#222;color:#fff;padding:8px;border-radius:6px"># install
npm init -y
npm install express ws

# run server (from repo root)
node server.js
# open http://localhost:3000 to test
</pre>
    <p>To let others connect from the internet, you must expose port 3000 (port-forwarding) or deploy the server to Replit/Heroku.</p>
    <div style="margin-top:8px"><button id="closeHost">Close</button></div>
  </div>

  <div id="dbg"></div>

  <!-- Three.js (UMD) -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <!-- PLAYERCONF definition -->
  <script>
    const PLAYERCONF = {
      speed: 4.2,     // walking speed
      jump: 8.5,      // jump strength
      gravity: -24.5, // gravity acceleration
      w: 0.72,        // player width
      h: 1.8,         // player height
      d: 0.42         // player depth
    };
  </script>
<script>
/* ===== UI & control wiring ===== */
const btnSingle = document.getElementById('btnSingle');
const btnMP = document.getElementById('btnMP');
const serverPanel = document.getElementById('serverPanel');
const btnConnect = document.getElementById('btnConnect');
const btnDisconnect = document.getElementById('btnDisconnect');
const serverAddrInput = document.getElementById('serverAddr');
const statText = document.getElementById('statText');
const btnHost = document.getElementById('btnHost');
const hostPanel = document.getElementById('menu');
const closeHost = document.getElementById('closeHost');
const dbgEl = document.getElementById('dbg');

function dbgLog(...args){ append('log', ...args); console._orig_log(...args); }
function dbgWarn(...args){ append('warn', ...args); console._orig_warn(...args); }
function dbgErr(...args){ append('err', ...args); console._orig_error(...args); }
function append(type, ...args){
  const line = document.createElement('div');
  line.className = type;
  line.textContent = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
  dbgEl.appendChild(line); dbgEl.scrollTop = dbgEl.scrollHeight;
}
(function hijackConsole(){ console._orig_log = console.log; console._orig_warn = console.warn; console._orig_error = console.error; console.log = dbgLog; console.warn = dbgWarn; console.error = dbgErr; })();

window.addEventListener('error', (e)=> append('err', `Error: ${e.message} (${e.filename}:${e.lineno})`));
window.addEventListener('unhandledrejection', (e)=> append('err','UnhandledRejection', e.reason));

btnSingle.onclick = () => startSinglePlayer();
btnMP.onclick = () => { serverPanel.style.display = serverPanel.style.display === 'block' ? 'none' : 'block'; };

btnConnect.onclick = () => {
  const addr = serverAddrInput.value.trim() || null;
  startMultiplayer(addr);
};
btnDisconnect.onclick = () => disconnectWS();

btnHost.onclick = () => { hostPanel.style.display = 'block'; };
closeHost.onclick = () => hostPanel.style.display = 'none';

/* ===== Scene, world, player (improved & lighter) ===== */
let scene, camera, renderer;
let world = {}, pickables = [], mats = {};
let player, vel = new THREE.Vector3(), yaw = 0, pitch = 0, onGround=false;
let lastTime = performance.now();
let selectedBlock = 'dirt';
let firstPerson = false;
let ws = null, clientId = null;
const WORLD_RADIUS = 18; // smaller — better perf
const MAX_BLOCKS = 4000; // safety cap

function initThree(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);
  renderer = new THREE.WebGLRenderer({antialias:true});
  // cap pixel ratio to reduce heavy devices
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1));
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);
  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
}

function createMats(){
  mats = {
    dirt: new THREE.MeshLambertMaterial({color:0x8B4513}),
    grass: new THREE.MeshLambertMaterial({color:0x2BAE2A}),
    stone: new THREE.MeshLambertMaterial({color:0xC2C2C2})
  };
}

function addLights(){
  const amb = new THREE.AmbientLight(0xffffff, 0.45); scene.add(amb);
  const sun = new THREE.DirectionalLight(0xffffff, 0.95); sun.position.set(80,120,40); sun.castShadow=true;
  sun.shadow.camera.left=-60; sun.shadow.camera.right=60; sun.shadow.camera.top=60; sun.shadow.camera.bottom=-60;
  sun.shadow.mapSize.set(1024,1024); scene.add(sun);
}

function key(x,y,z){ return `${x},${y},${z}`; }

function addBlock(x,y,z,type='dirt', fromServer=false){
  if(Object.keys(world).length > MAX_BLOCKS) return; // safety
  const id = key(x,y,z);
  if(world[id]) return;
  const geo = new THREE.BoxGeometry(1,1,1);
  const m = new THREE.Mesh(geo, mats[type] || mats.dirt);
  m.position.set(x,y,z);
  m.castShadow = true; m.receiveShadow = true;
  m.userData.type = type;
  scene.add(m);
  world[id] = m;
  pickables.push(m);
}

function removeBlock(x,y,z, fromServer=false){
  const id = key(x,y,z); const m = world[id];
  if(!m) return;
  scene.remove(m);
  const idx = pickables.indexOf(m); if(idx !== -1) pickables.splice(idx,1);
  delete world[id];
}

function generateLocalWorld(){
  // lighter local world
  for(let x=-WORLD_RADIUS;x<=WORLD_RADIUS;x++){
    for(let z=-WORLD_RADIUS;z<=WORLD_RADIUS;z++){
      const h = Math.max(0, Math.floor(Math.sin(x*0.12)*2 + Math.cos(z*0.09)*2 + 2 + Math.random()*1.2));
      for(let y=0;y<=h;y++){
        const type = (y<h-2) ? 'stone' : (y===h && Math.random()>0.88 ? 'grass' : 'dirt');
        addBlock(x,y,z,type,true);
      }
    }
  }
}

/* player & model */
function createPlayer(){
  player = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.8,1.0,0.4), new THREE.MeshLambertMaterial({color:0x00aaff}));
  body.position.set(0,1.25,0);
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.7,0.7,0.7), new THREE.MeshLambertMaterial({color:0xffd9b3}));
  head.position.set(0,1.9,0);
  const armL = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.9,0.2), new THREE.MeshLambertMaterial({color:0xffc4a3}));
  armL.position.set(-0.6,1.25,0); const armR = armL.clone(); armR.position.set(0.6,1.25,0);
  const legL = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.9,0.3), new THREE.MeshLambertMaterial({color:0x333333}));
  legL.position.set(-0.18,0.45,0); const legR = legL.clone(); legR.position.set(0.18,0.45,0);
  player.add(body, head, armL, armR, legL, legR);
  player.position.set(0, 6, 6);
  scene.add(player);
}

/* camera & pointer-lock (movement works even w/o lock) */
let pointerLocked = false;
function enablePointerLock(){
  renderer.domElement.addEventListener('click', ()=> renderer.domElement.requestPointerLock?.());
  document.addEventListener('pointerlockchange', ()=> pointerLocked = (document.pointerLockElement === renderer.domElement));
  document.addEventListener('mousemove', (e)=> {
    if(!pointerLocked) return;
    const sens = 0.0022; yaw -= (e.movementX||0)*sens; pitch -= (e.movementY||0)*sens;
    pitch = Math.max(-Math.PI/2+0.01, Math.min(Math.PI/2-0.01,pitch));
    if(!firstPerson) player.rotation.y = yaw;
  });
}

/* input */
const keys = {}; window.addEventListener('keydown', (e)=> { keys[e.key.toLowerCase()] = true; if(e.key==='Escape') document.exitPointerLock?.(); if(e.key.toLowerCase()==='v') { firstPerson=!firstPerson; document.getElementById('viewMode') && (document.getElementById('viewMode').innerText = firstPerson ? 'First-person':'Third-person'); } }); window.addEventListener('keyup', (e)=> keys[e.key.toLowerCase()] = false);

document.querySelectorAll('.slot').forEach(s => s.addEventListener('click', ()=> { document.querySelectorAll('.slot').forEach(x=>x.classList.remove('sel')); s.classList.add('sel'); selectedBlock = s.dataset.type; }));
window.addEventListener('keydown', (e)=> { if(['1','2','3'].includes(e.key)){ const map={'1':'dirt','2':'grass','3':'stone'}[e.key]; document.querySelectorAll('.slot').forEach(x=>x.classList.toggle('sel', x.dataset.type===map)); selectedBlock = map; } });

/* raycast place/break */
const ray = new THREE.Raycaster();
function onPointerDown(e){
  if(e.button!==0 && e.button!==2) return;
  const rect = renderer.domElement.getBoundingClientRect();
  const mx = ((e.clientX-rect.left)/rect.width)*2 - 1;
  const my = -((e.clientY-rect.top)/rect.height)*2 + 1;
  ray.setFromCamera(new THREE.Vector2(mx,my), camera);
  const hits = ray.intersectObjects(pickables, false);
  if(!hits.length) return;
  const hit = hits[0];
  if(e.button === 2){ // break
    const p = hit.object.position; removeBlock(p.x,p.y,p.z,true); sendIfConnected({t:'remove',x:p.x,y:p.y,z:p.z});
  } else { // place
    const pos = hit.object.position.clone(); const n = hit.face.normal.clone(); const t = pos.add(n);
    const tx=Math.round(t.x), ty=Math.round(t.y), tz=Math.round(t.z);
    addBlock(tx,ty,tz,selectedBlock,true); sendIfConnected({t:'place',x:tx,y:ty,z:tz,type:selectedBlock});
  }
}
window.addEventListener('pointerdown', onPointerDown);
window.addEventListener('contextmenu', e => e.preventDefault());

/* multiplayer WS logic */
function getServerAddr(){
  try { const p = new URLSearchParams(location.search); const w = p.get('ws'); if(w) return w; } catch(e){}
  const input = serverAddrInput.value.trim();
  if(input) return input;
  // default try same host (use wss on https)
  return (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host;
}
function startMultiplayer(addr=null){
  const server = addr || getServerAddr();
  statText.innerText = 'connecting... ' + server;
  dbgLog('Trying WS:', server);
  try {
    ws = new WebSocket(server);
  } catch(e){ dbgErr('WS connect throw', e); statText.innerText = 'connect error'; return; }

  let initReceived = false;
  const initTimer = setTimeout(()=>{ if(!initReceived){ dbgWarn('WS init timeout; falling back to single-player'); ws && ws.close(); statText.innerText = 'init timeout'; fallbackToLocal(); } }, 2500);

  ws.onopen = ()=>{ dbgLog('WS open'); statText.innerText = 'connected'; };
  ws.onmessage = (ev) => {
    try {
      const d = JSON.parse(ev.data);
      if(d.t === 'init'){
        initReceived = true; clearTimeout(initTimer);
        clientId = d.id; dbgLog('Init received id',d.id);
        // clear local world and apply server blocks (simple reset)
        for(const k in world){ const p = k.split(',').map(Number); removeBlock(p[0],p[1],p[2],true); }
        (d.blocks||[]).forEach(b => addBlock(b.x,b.y,b.z,b.type,true));
      } else if(d.t==='place'){ addBlock(d.x,d.y,d.z,d.type,true); }
      else if(d.t==='remove'){ removeBlock(d.x,d.y,d.z,true); }
      else if(d.t==='move'){ /* remote player movement handled later if desired */ }
      else if(d.t==='join'){ dbgLog('Join', d.id); }
      else if(d.t==='leave'){ dbgLog('Leave', d.id); }
    } catch(e){ dbgErr('Bad WS msg', e); }
  };
  ws.onerror = (e) => { dbgErr('WS error', e); statText.innerText = 'error'; };
  ws.onclose = () => { dbgWarn('WS closed'); statText.innerText = 'not connected'; ws=null; };
}

function disconnectWS(){
  if(ws){ ws.close(); ws=null; statText.innerText='disconnected'; dbgLog('Disconnected'); } else dbgLog('Not connected');
}
function sendIfConnected(obj){ if(ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(obj)); }

/* physics (improved & less heavy) */
function aabbIntersects(px,py,pz, halfW, halfH, halfD){
  const minX = Math.floor(px-halfW), maxX=Math.floor(px+halfW);
  const minY = Math.floor(py-halfH), maxY=Math.floor(py+halfH);
  const minZ = Math.floor(pz-halfD), maxZ=Math.floor(pz+halfD);
  for(let x=minX;x<=maxX;x++) for(let y=minY;y<=maxY;y++) for(let z=minZ;z<=maxZ;z++) if(world[key(x,y,z)]) return true;
  return false;
}

function updateLoop(){
  const now = performance.now();
  const dt = Math.min(0.05,(now-lastTime)/1000);
  lastTime = now;

  // movement
  const forward = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
  const right = new THREE.Vector3(Math.sin(yaw+Math.PI/2),0,Math.cos(yaw+Math.PI/2));
  const move = new THREE.Vector3();
  if(keys['w']) move.add(forward); if(keys['s']) move.sub(forward);
  if(keys['a']) move.sub(right); if(keys['d']) move.add(right);
  if(move.lengthSq()>0.0001) move.normalize();
  const speed = PLAYERCONF.speed * (keys['shift'] ? 1.8:1);
  vel.x = THREE.MathUtils.lerp(vel.x, move.x*speed, 0.12);
  vel.z = THREE.MathUtils.lerp(vel.z, move.z*speed, 0.12);

  if(keys[' '] && onGround){ vel.y = PLAYERCONF.jump; onGround=false; }
  vel.y += PLAYERCONF.gravity * dt;

  // integrate
  const desired = player.position.clone().addScaledVector(vel, dt);
  // Y
  const halfW = PLAYERCONF.w/2, halfH = PLAYERCONF.h/2, halfD = PLAYERCONF.d/2;
  const testY = player.position.clone(); testY.y = desired.y;
  if(aabbIntersects(testY.x,testY.y,testY.z, halfW, halfH, halfD)){
    if(vel.y < 0){
      const px = Math.round(player.position.x), pz = Math.round(player.position.z);
      let top = -Infinity;
      for(let yy=Math.floor(player.position.y-4); yy<=Math.floor(player.position.y+3); yy++) if(world[key(px,yy,pz)]) top = Math.max(top,yy);
      if(isFinite(top)){ player.position.y = top + 0.5 + halfH + 0.001; }
      vel.y = 0; onGround=true;
    } else vel.y = 0;
  } else { player.position.y = testY.y; onGround=false; }

  // X and Z
  const testX = player.position.clone(); testX.x = desired.x;
  if(!aabbIntersects(testX.x,testX.y,testX.z, halfW, halfH, halfD)) player.position.x = testX.x; else vel.x=0;
  const testZ = player.position.clone(); testZ.z = desired.z;
  if(!aabbIntersects(testZ.x,testZ.y,testZ.z, halfW, halfH, halfD)) player.position.z = testZ.z; else vel.z=0;

  // camera follow / look
  updateCamera();

  renderer.render(scene, camera);
  requestAnimationFrame(updateLoop);
}

/* camera follow */
function updateCamera(){
  if(firstPerson){
    camera.position.copy(player.position).add(new THREE.Vector3(0,PLAYERCONF.h-0.2,0));
    camera.rotation.set(pitch, yaw, 0, 'YXZ');
  } else {
    // third-person camera (simple chase cam)
    const camDist = 4.5, camHeight = 2.1;
    const camOff = new THREE.Vector3(Math.sin(yaw)*-camDist, camHeight, Math.cos(yaw)*-camDist);
    camera.position.copy(player.position).add(camOff);
    camera.lookAt(player.position.x, player.position.y+1.3, player.position.z);
  }
}

/* start single-player quickly */
function startSinglePlayer(){
  clearScene();
  initThree(); createMats(); addLights(); createPlayer(); generateLocalWorld(); enablePointerLock();
  lastTime = performance.now(); updateLoop();
  statText.innerText = 'single-player';
}

/* start multiplayer (connect) */
function startMultiplayer(addr){
  clearScene();
  initThree(); createMats(); addLights(); createPlayer(); enablePointerLock();
  // try WS connect and rely on server's init or fallback
  startMultiplayerInternal(addr);
  lastTime = performance.now(); updateLoop();
}

function startMultiplayerInternal(addr){
  const server = addr || getServerAddr();
  startMultiplayer(server);
}

/* clear scene/world (when switching) */
function clearScene(){
  try {
    if(renderer && renderer.domElement){ document.body.removeChild(renderer.domElement); }
  } catch(e){ dbgWarn('remove canvas failed', e); }
  scene = null; camera=null; renderer=null; world={}; pickables=[]; mats={};
  // reset player etc
  player=null; vel.set(0,0,0); yaw = 0; pitch = 0; onGround=false;
}

/* fallback local if WS fails */
function fallbackToLocal(){ if(Object.keys(world).length===0){ dbgLog('Generating local world fallback'); generateLocalWorld(); } }

/* initial default: start singleplayer so user can move immediately */
document.addEventListener('DOMContentLoaded', ()=>{
  // start single player by default so it's responsive immediately
  startSinglePlayer();
  // auto-try connect if ?ws= is present
  try{
    const p = new URLSearchParams(location.search); const w = p.get('ws');
    if(w){ serverAddrInput.value = w; serverPanel.style.display='block'; startMultiplayer(w); }
  }catch(e){}
});
</script>
</body>
</html>
